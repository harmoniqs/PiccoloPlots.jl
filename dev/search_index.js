var documenterSearchIndex = {"docs":
[{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#PiccoloPlots.QuantumObjectPlots.plot_state_populations-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"PiccoloPlots.QuantumObjectPlots.plot_state_populations","text":"plot_state_populations(\n    traj::NamedTrajectory;\n    state_name::Symbol=:ψ̃,\n    state_indices::Union{Nothing, AbstractVector{Int}}=nothing,\n    control_name::Symbol=:u,\n    subspace::Union{Nothing, AbstractVector{Int}}=nothing,\n    kwargs...\n)\n\nPlot populations for multiple quantum states stored in a trajectory.\n\nThis function visualizes the time evolution of quantum state populations for trajectories containing multiple state trajectories (e.g., from sampling problems where multiple initial states are evolved). States are identified by a common prefix and numeric suffix pattern (e.g., :ψ̃1_system_1, :ψ̃2_system_1, etc.).\n\nMathematical Background\n\nFor a quantum state psi(t)rangle in mathcalH evolving under the Schrödinger equation, the population in computational basis state irangle is given by\n\nP_i(t) = langle ipsi(t)rangle^2 = psi_i(t)^2\n\nwhere psi_i(t) is the i-th component of the state vector in the computational basis.\n\nFor a normalized state, we have the conservation property:\n\nsum_i=1^n P_i(t) = langlepsi(t)psi(t)rangle = 1\n\nWhen multiple states are being optimized simultaneously (as in sampling problems), this function plots the populations for each state, allowing comparison of how different initial conditions evolve under the same control protocol.\n\nKey Properties:\n\nPopulations are real and bounded: P_i(t) in 01\nTotal probability is conserved: sum_i P_i(t) = 1\nCan optionally restrict to a subspace (e.g., computational subspace excluding leakage states)\n\nArguments\n\ntraj::NamedTrajectory: A trajectory containing one or more quantum states in isomorphism representation.\n\nKeyword Arguments\n\nstate_name::Symbol: The base name for state components. The function will find all trajectory components matching this prefix (e.g., :ψ̃ matches :ψ̃1_system_1, :ψ̃2_system_1, etc.). Default is :ψ̃.\nstate_indices::Union{Nothing, AbstractVector{Int}}: If provided, only plot states with these indices (e.g., [1, 3] plots only the 1st and 3rd states). If nothing, plots all states matching the prefix. Default is nothing.\ncontrol_name::Symbol: The name of the control signal component to include in the plot. Default is :u.\nsubspace::Union{Nothing, AbstractVector{Int}}: If provided, only plot populations for these basis states (e.g., 1:2 for a qubit subspace). Useful for excluding leakage levels. Default is nothing (plot all levels).\nkwargs...: Additional keyword arguments passed to NamedTrajectories.plot.\n\nReturns\n\nA Makie Figure object containing the population plots for all selected states.\n\nExample\n\nusing NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots\n\n# Example: Two initial states evolving under the same controls\nN = 100\nΔt = 0.1\n\n# Initial states\nψ1_init = ComplexF64[1, 0, 0]  # |0⟩\nψ2_init = ComplexF64[0, 1, 0]  # |1⟩\n\n# Create trajectory with multiple states\ntraj = NamedTrajectory(\n    (\n        ψ̃1_system_1 = hcat([ket_to_iso(ψ1_init) for _ in 1:N]...),\n        ψ̃2_system_1 = hcat([ket_to_iso(ψ2_init) for _ in 1:N]...),\n        u = randn(2, N),\n        Δt = fill(Δt, N),\n    );\n    controls = :u,\n    timestep = :Δt,\n)\n\n# Plot populations for all states\nplot_state_populations(traj)\n\n# Plot only computational subspace (excluding 3rd level)\nplot_state_populations(traj; subspace=1:2)\n\n# Plot only first state\nplot_state_populations(traj; state_indices=[1])\n\nSee also: plot_unitary_populations, NamedTrajectories.plot\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloPlots.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"PiccoloPlots.QuantumObjectPlots.plot_unitary_populations","text":"plot_unitary_populations(\n    traj::NamedTrajectory;\n    unitary_columns::AbstractVector{Int}=1:2,\n    unitary_name::Symbol=:Ũ⃗,\n    control_name::Symbol=:u,\n    kwargs...\n)\n\nPlot the state populations for specified columns of a unitary operator trajectory.\n\nThis function visualizes how the populations (squared magnitudes) of quantum states evolve over time for selected columns of a unitary matrix stored in a NamedTrajectory.\n\nMathematical Background\n\nFor a unitary operator U(t) in mathcalU(n) evolving under a time-dependent Hamiltonian, this function plots the populations\n\nP_ij(t) = U_ij(t)^2\n\nwhere U_ij(t) is the (ij)-th element of the unitary matrix at time t.\n\nFor a quantum system evolving according to the Schrödinger equation\n\nfracddtU(t) = -iH(t)U(t) quad U(0) = I\n\neach column j of U(t) represents the time evolution of the initial basis state jrangle:\n\npsi_j(t)rangle = U(t)jrangle = sum_i=1^n U_ij(t)irangle\n\nThe population P_ij(t) = U_ij(t)^2 gives the probability of finding the system in state irangle at time t given that it started in state jrangle.\n\nKey Properties:\n\nUnitarity ensures sum_i=1^n P_ij(t) = 1 for all j and t (probability conservation)\nP_ij(0) = delta_ij (initially in definite state)\nPopulations are real and bounded: P_ij(t) in 01\n\nThe trajectory stores U(t) in isomorphism representation tildeU(t), a vectorized form that preserves the operator structure while enabling efficient optimization algorithms.\n\nArguments\n\ntraj::NamedTrajectory: A trajectory containing a unitary operator in isomorphism representation.\n\nKeyword Arguments\n\nunitary_columns::AbstractVector{Int}: Indices of unitary matrix columns to plot. Each column j corresponds to the evolution of basis state jrangle. Default is 1:2.\nunitary_name::Symbol: The name of the unitary operator component in the trajectory, stored as an isomorphism vector (tildeU). Default is :Ũ⃗.\ncontrol_name::Symbol: The name of the control signal component to include in the plot, typically the time-dependent control parameters u(t) in H(t) = H_0 + sum_k u_k(t) H_k. Default is :u.\nkwargs...: Additional keyword arguments passed to NamedTrajectories.plot, such as xlims, ylims, or Makie-specific plotting options.\n\nReturns\n\nA Makie Figure object containing the population plots.\n\nExample\n\nusing NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots\n\n# Define Hamiltonian: H = X + a₁(t)Z + a₂(t)Y\nH_drift = PAULIS[:X]\nH_drives = [PAULIS[:Z], PAULIS[:Y]]\n\n# Generate control trajectory\nN = 100\nΔt = 0.1\nts = collect(0:Δt:Δt*(N-1))\nu = 0.1 * randn(2, length(ts))\n\n# Generate unitaries\nUs = exp.(-im * [(H_drift + sum(u[:, k] .* H_drives)) * ts[k] for k = 1:N])\n\n# Create trajectory\ntraj = NamedTrajectory(\n    (\n        Ũ⃗ = hcat(operator_to_iso_vec.(Us)...),\n        u = u,\n        Δt = ts,\n    );\n    controls = :u,\n    timestep = :Δt,\n)\n\n# Plot populations for first two columns\nplot_unitary_populations(traj)\n\n# Plot only the first column\nplot_unitary_populations(traj; unitary_columns=[1])\n\nSee also: NamedTrajectories.plot\n\n\n\n\n\n","category":"method"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Here is a simple example where we set up a NamedTrajectory with some dummy data and plot populations of the columns of the unitary matrix. First we will load some of the necessary packages:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using CairoMakie\nusing NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Next we will define some Hamiltonians","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H_drives = [PAULIS[:Z], PAULIS[:Y]]\nH_drift = PAULIS[:X]","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Now we will generate some dummy control data","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"N = 100\nΔt = 0.1\nts = 0:Δt:Δt*(N-1)\nu = 0.1 * randn(length(H_drives), length(ts))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Now we will generate the unitaries","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Us = exp.(-im * [(H_drift + sum(u[:, k] .* H_drives)) * ts[k] for k = 1:N])\nUs[1]","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"And create the trajectory","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj = NamedTrajectory(\n    (\n        Ũ⃗ = hcat(operator_to_iso_vec.(Us)...), # here we store the isomorphisms\n        u = u,\n        Δt = fill(Δt, N)\n    );\n    controls = :u,\n    timestep = :Δt\n)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Finally we will plot the populations","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot_unitary_populations(traj)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also only plot the first column (or any other subset of columns)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot_unitary_populations(traj; unitary_columns=[1])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"logo\" width=\"25%\"/>\n  </a> \n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/PiccoloPlots/stable/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/PiccoloPlots/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/PiccoloPlots.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/PiccoloPlots.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/PiccoloPlots.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/PiccoloPlots.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n  <i>Easy plotting of quantum control trajectories</i>\n  <br>\n</div>","category":"page"},{"location":"#PiccoloPlots.jl","page":"Home","title":"PiccoloPlots.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PiccoloPlots.jl is designed to hold plotting recipes for the Piccolo.jl package. It utilzes the plot method of the NamedTrajectories.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PiccoloPlots.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add PiccoloPlots","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a simple example, we provide the plot_unitary_populations function which plots the populations of select columns of the unitary matrix. This can be employed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots\n\n# Define the Hamiltonian H = X + u_1(t)Z + u_2(t)Y\nH_drift = PAULIS[:X]\nH_drives = [PAULIS[:Z], PAULIS[:Y]]\n\n# Generate control trajectory \nN = 100\n\nΔt = 0.1\nts = collect(0:Δt:Δt*(N-1))\n\nu = 0.1 * randn(length(H_drives), length(ts))\n\n# Generate the unitaries\nUs = exp.(-im * [(H_drift + sum(u[:, k] .* H_drives)) * ts[k] for k = 1:N])\n\n# Create a NamedTrajectory\ntraj = NamedTrajectory(\n    (\n        Ũ⃗ = hcat(operator_to_iso_vec.(Us)...),\n        u = u,\n        Δt = fill(Δt, N),\n    );\n    controls = :u,\n    timestep = :Δt,\n)\n\n# Plot the populations of the first and second qubits\nplot_unitary_populations(traj)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n![](assets/unitary_populations.png)\n\n\n### Building Documentation\nThis package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. ","category":"page"},{"location":"#first-time-only","page":"Home","title":"first time only","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"./docs/getdocsutils.sh   # or ./getdocsutils.sh if cwd is in ./docs/","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nTo build the docs pages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia –project=docs docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nor editing the docs live:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia –project=docs","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LiveServer, PiccoloPlots, Revise servedocs(literatedir=\"docs/literate\", skipdirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n> **Note:** `servedocs` needs to watch a subset of the files in the `docs/` folder. If it watches files that are generated on a docs build/re-build, `servedocs` will continuously try to re-serve the pages.\n> \n> To prevent this, ensure all generated files are included in the skip dirs or skip files args for `servedocs`.\n\nFor example, if we forget index.md like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia –project=docs","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LiveServer, PiccoloPlots, Revise servedocs(literatedir=\"docs/literate\", skipdirs=[\"docs/src/generated\", \"docs/src/assets/\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"``` it will not build and serve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry","category":"page"}]
}
